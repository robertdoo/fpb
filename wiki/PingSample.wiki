#summary 使用ICMPv4协议实现的Ping应用
#labels Phase-Support

= Introduction =

使用ICMPv4协议的Echo Request和Echo Reply报文来实现Ping应用。用了已定义的EtherProtocol类型和Ipv4Protocol和Icmpv4Protocol类型来实现了Ping类，然后可以用该Ping类来执行Ping功能。 


= Details =

*Ping类的使用方法例：*
{{{
//生成Pcap套接字来实现链路层通信
PcapSocketImpl socket = new PcapSocketImpl(FpbTestUtil.getInterface().name);
//生成Arp对象
Arp arp = new Arp(socket, LOCAL_MAC, LOCAL_IP);
//取得目标设备的MAC地址
String dstMac = arp.askMac("192.168.11.1");
//生成Ping对象
Ping ping = new Ping(socket, LOCAL_MAC, dstMac, LOCAL_IP);
//执行Ping(循环三次)
ping.ping(3, "192.168.11.1");
}}}

*上述代码的执行结果例:*
{{{
Reply from 192.168.11.1 bytes=32 time<=0.031(s) TTL=64
Reply from 192.168.11.1 bytes=32 time<=0.0(s) TTL=64
Reply from 192.168.11.1 bytes=32 time<=0.0(s) TTL=64
}}}

*Echo Request报文的打印例：*
{{{
0:74  sample.EtherProtocol   
0:6     dstAddress           "00160115A488"O 
6:6     srcAddress           "0016D41725C4"O 
12:2    etherType            2048 IPv4
14:60   payload              
14:60     ipv4               sample.Ipv4Protocol
14:60 sample.Ipv4Protocol    
14:20   header               
14:1      0000----           4 version 0xF0 
14:1      ----0000           5 headerLength 0x0F 
15:1      typeOfService      "00000000"B 
16:2      totalLength        60 
18:2      identification     1 
20:1      0---------------   0 reserved 0x8000 Must be zero
20:1      -0--------------   0 doNotFlagFlag 0x4000 May fragment
20:1      --0-------------   0 moreFlagsFlag 0x2000 Last fragment
20:2      ---0000000000000   0 fragmentOffset 0x1FFF 
22:1      timeToLive         255 
23:1      protocol           1 ICMP: Internet Control Message Protocol
24:2      hcs                "0000"O 
26:4      sourceAddress      "C0A80B05"O 
30:4      destinationAddress "C0A80B01"O 
34:0      options            omit 
34:40   payload              
34:40     icmpv4             sample.Icmpv4Protocol
34:40 sample.Icmpv4Protocol  
34:40   echoRequest          
34:1      type               8 
35:1      code               0 
36:2      checksum           "0000"O 
38:2      identifier         56255 
40:2      sequenceNumber     0 
42:32     data               {} 
      0000 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f  ................
      0010 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f  ................
74:0    fcs                  omit
}}}

*Echo Reply报文的打印例：*
{{{
0:74  sample.EtherProtocol   
0:6     dstAddress           "0016D41725C4"O 
6:6     srcAddress           "00160115A488"O 
12:2    etherType            2048 IPv4
14:60   payload              
14:60     ipv4               sample.Ipv4Protocol
14:60 sample.Ipv4Protocol    
14:20   header               
14:1      0000----           4 version 0xF0 
14:1      ----0000           5 headerLength 0x0F 
15:1      typeOfService      "00000000"B 
16:2      totalLength        60 
18:2      identification     25324 
20:1      0---------------   0 reserved 0x8000 Must be zero
20:1      -0--------------   0 doNotFlagFlag 0x4000 May fragment
20:1      --0-------------   0 moreFlagsFlag 0x2000 Last fragment
20:2      ---0000000000000   0 fragmentOffset 0x1FFF 
22:1      timeToLive         64 
23:1      protocol           1 ICMP: Internet Control Message Protocol
24:2      hcs                "807E"O 
26:4      sourceAddress      "C0A80B01"O 
30:4      destinationAddress "C0A80B05"O 
34:0      options            omit 
34:40   payload              
34:40     icmpv4             sample.Icmpv4Protocol
34:40 sample.Icmpv4Protocol  
34:40   echoReply            
34:1      type               0 
35:1      code               0 
36:2      checksum           "333F"O 
38:2      identifier         56255 
40:2      sequenceNumber     0 
42:32     data               {} 
      0000 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f  ................
      0010 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f  ................
74:0    fcs                  omit 
}}}

*Ping类的源代码：*
{{{
/**
 * 使用ICMPv4协议实现的Ping协议。
 * 使用ICMPv4协议的Echo Request和Echo Reply报文来实现Ping应用。
 */
public static class Ping {
    private static SampleModule module = SampleModule.INSTANCE;
    private static SampleFactory factory = SampleFactory.INSTANCE;
    private static PValueSerializer ser = PValueSerializer.INSTANCE;
    private static int ICMP_REQUEST_DATA_BYTES = 32;
    private String srcMac;
    private String dstMac;
    private String srcIp;
    private PcapSocket socket;
    private int timeout = CommonSocket.DEFAULT_TIMEOUT;
    
    /**
     * 构造函数
     * @param socket PCAP套接字
     * @param srcMac 源设备的MAC地址
     * @param dstMac 目标设备的MAC地址
     * @param srcIp 源设备的IP地址
     */
    public Ping(PcapSocket socket, String srcMac, String dstMac, String srcIp) {
        this.socket = socket;
        this.srcMac = srcMac;
        this.dstMac = dstMac;
        this.srcIp = srcIp;
    }
    /**
     * 生成ICMPv4的Echo Request报文数据包。协议栈为Ethernet/IPv4/ICMPv4。
     * @param dstIp 目标设备的IP地址。
     * @param icmpId Echo Request中的标识符
     * @param icmpSeq Echo Request中的序号
     * @return
     */
    private EtherProtocol createPingRequest(String dstIp, int icmpId, int icmpSeq) {
        EtherProtocol etherPrtl = factory.createEtherProtocol();
        etherPrtl.getDstAddress().setTextAs(dstMac, PValueTextStyle.MAC_ADDRESS);
        etherPrtl.getSrcAddress().setTextAs(srcMac, PValueTextStyle.MAC_ADDRESS);
        etherPrtl.getEtherType().setInteger(0x0800);
        
        Ipv4Protocol ipv4Prtl = factory.createIpv4Protocol();
        Ipv4Header header = ipv4Prtl.getHeader();
        header.getIdentification().setInteger(1);
        header.getTimeToLive().setInteger(255);
        header.getProtocol().setInteger(1);
        header.getSourceAddress().setTextAs(srcIp, PValueTextStyle.IPV4_ADDRESS);
        header.getDestinationAddress().setTextAs(dstIp, PValueTextStyle.IPV4_ADDRESS);
        etherPrtl.getPayload().pSetFieldByID(SampleModule.ETHER_PAYLOAD__IPV4, ipv4Prtl);
        
        PUnionValue icmpv4Prtl = factory.createIcmpv4Protocol();
        ipv4Prtl.getPayload().pSetFieldByID(SampleModule.IPV4_PAYLOAD__ICMPV4, icmpv4Prtl);
        Icmpv4EchoRequest echoRequest = factory.createIcmpv4EchoRequest();
        icmpv4Prtl.pSetFieldByID(SampleModule.ICMPV4_PROTOCOL__ECHO_REQUEST, echoRequest);
        echoRequest.getIndentifier().setInteger(icmpId);
        echoRequest.getSequenceNumber().setInteger(icmpSeq);
        
        byte[] data = new byte[ICMP_REQUEST_DATA_BYTES];
        for (int i = 0; i < data.length; i++) {
            data[i] = (byte)i;
        }
        echoRequest.getData().setValue(data);
        return etherPrtl;
    }
    /**
     * 根据指示的目标设备IP地址通过ICMPv4协议来检验源设备到目标设备的网路是否连通。检验结果会被打印在
     * 标准输出中。
     * @param cnt 检验次数，即Echo请求的发送次数。
     * @param dstIp 目标设备的IP地址
     * @throws Exception
     */
    public void ping(int cnt, String dstIp) throws Exception {
        byte[] resData = new byte[1514];
        socket.setTimeout(timeout);
        //打开套接字
        socket.open();
        try {
            //设置Pcap套接字的过滤条件。（过滤条件的书写规则可以参考WinPcap的用户手册）
            socket.setFilter("ip dst " + srcIp + " and icmp", true);
            //生成随机的ICMP Echo请求的标识符
            int icmpId = (int)(Math.random() * 0xFFFF);
            //进行多次Ping检验
            for (int i = 0; i < cnt; i++) {
                //ICMP Echo请求的序号
                int seqNo = i;
                //生成ICMP Echo请求报文
                EtherProtocol pingRequest = createPingRequest(dstIp, icmpId, seqNo);
                //对报文数据包内的可计算字段进行自动计算（这里是IP协议的HeaderLength和TotalLength字段）
                ser.calculate(pingRequest);
                //打印报文内容
//              PValueDumper.INSTANCE.dump(pingRequest);
                //编码
                byte data[] = ser.encode(pingRequest, false);
                //发送编码数据
                socket.write(data);
                //起始时间
                long startTime = System.currentTimeMillis();
                //已花费时间（计算超时）
                long totalTime = 0;
                //循环接收数据包直到超时
                while (totalTime < timeout) {
                    //接收数据
                    int len;
                    try {
                        len = socket.read(resData);
                    } catch (CommTimeoutException e) {
                        totalTime = timeout;
                        break;
                    }
                    //解码（底层协议为Ethernet所以使用EtherProtocol作为推测类型）
                    EtherProtocol pingResponse = (EtherProtocol)ser.decode(resData, 0, len, 
                            module.getEtherProtocol());
                    //打印报文
//                  PValueDumper.INSTANCE.dump(pingResponse);
                    //取得花费时间
                    totalTime = System.currentTimeMillis() - startTime;
                    //从EthernetProtocol的Payload字段里取出IPv4协议字段
                    Ipv4Protocol ipv4Prtl = pingResponse.getPayload().getIpv4();
                    if (ipv4Prtl == null) {
                        continue;
                    }
                    //从Ipv4Protocol地Payload字段里取出Icmpv4协议字段
                    Icmpv4Protocol icmpv4Prtl = ipv4Prtl.getPayload().getIcmpv4();
                    if (icmpv4Prtl == null) {
                        continue;
                    }
                    //从Icmpv4Protocol中取出EchoReply字段
                    Icmpv4EchoReply echoReply = icmpv4Prtl.getEchoReply();
                    if (echoReply == null) {
                        continue;
                    }
                    //判断EchoReply的标识符和序号是否与EchoRequest的一致
                    if (echoReply.getIndentifier().getInteger() != icmpId || 
                            echoReply.getSequenceNumber().getInteger() != seqNo) {
                        continue;
                    }
                    //取得目标设备的IP地址
                    String tempIp = ipv4Prtl.getHeader().getSourceAddress().getTextAs(
                            PValueTextStyle.IPV4_ADDRESS);
                    //取得EchoReply中的Data字段的长度（字节数）
                    int dataLen = echoReply.getData().getLength();
                    //取得IPv4的TTL字段值
                    int ttl = ipv4Prtl.getHeader().getTimeToLive().getInteger();
                    //打印检验结果
                    String msg = "Reply from " + tempIp + " bytes=" + dataLen + " time<=" +
                    totalTime/1000.0 + "(s)" + " TTL=" + ttl;
                    System.out.println(msg);
                    break;
                }
                //判断是否超时
                if (totalTime >= timeout) {
                    System.out.println("timeout");
                }
            }
        } finally {
            //关闭套接字
            socket.close();
        }
    }
    
}
}}}